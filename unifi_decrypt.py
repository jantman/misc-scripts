#!/usr/bin/env python
"""
Script to decrypt and extract UniFi backup autobackup.unf files.

If you have ideas for improvements, or want the latest version, it's at:
<https://github.com/jantman/misc-scripts/blob/master/unifi_decrypt.py>

Based on the decrypt.sh shell script from https://github.com/zhangyoufu/unifi-backup-decrypt
Licensed under "The Unlicense" (public domain)

REQUIREMENTS:

Python >= 3.6 (written for 3.10)
pycryptodome
`zip` binary, used to fix the corrupt zip file generated by unifi

NOTE: After decrypting, the resulting zip file has all sorts of problems. Most
of the UniFi decryption shell scripts that I've seen run the file through
`zip -FF` to fix it. I attempted a number of methods of fixing the zip file in
native Python, but they all failed. If anyone comes up with a native Python
method of fixing the file instead of the ugly subprocess of `zip` that I'm using
here, please let me know.
"""

import sys
import os
import argparse
import logging
from io import BytesIO
from zipfile import ZipFile, ZipInfo, ZIP_DEFLATED
from subprocess import Popen, CompletedProcess, PIPE

# pycryptodome
from Crypto.Cipher import AES

FORMAT: str = "[%(asctime)s %(levelname)s] %(message)s"
logging.basicConfig(level=logging.WARNING, format=FORMAT)
logger: logging.Logger = logging.getLogger()


class UnifiBackupDecrypter:

    #: decryption key
    KEY: bytes = bytes.fromhex('626379616e676b6d6c756f686d617273')

    #: initialization vector
    IV: bytes = bytes.fromhex('75626e74656e74657270726973656170')

    def _fix_zipfile(self, content: bytes) -> bytes:
        cmd = ['zip', '-FF', '-', '--out', '-']
        logger.info('Executing: %s', ' '.join(cmd))
        p = Popen(cmd, stdin=PIPE, stdout=PIPE)
        out, err = p.communicate(content)
        if p.returncode != 0:
            logger.error(
                'zip command exited %d; stdout=%s\nstderr=%s',
                p.returncode, out, err
            )
            raise RuntimeError('zip error')
        logger.info(
            'zip command exited %d with %d bytes of output',
            p.returncode, len(out)
        )
        return out

    def run(self, backup: str, outdir: str = 'autobackup'):
        if not os.path.exists(outdir):
            os.mkdir(outdir)
        logger.debug('Reading: %s', backup)
        with open(backup, 'rb') as fh:
            ciphertext: bytes = fh.read()
        logger.info('Decrypting %d bytes', len(ciphertext))
        cipher: AES = AES.new(self.KEY, AES.MODE_CBC, iv=self.IV)
        plaintext: bytes = cipher.decrypt(ciphertext)
        #plaintext = self._fix_zipfile(plaintext)
        zf: ZipFile = ZipFile(BytesIO(plaintext), "r", compression=ZIP_DEFLATED)
        fileinfo: ZipInfo
        for fileinfo in zf.infolist():
            logger.info('Extracting: %s', fileinfo.filename)
            zf.extract(fileinfo, outdir)


def parse_args(argv):
    p = argparse.ArgumentParser(description='UniFi backup decrypter')
    p.add_argument('-v', '--verbose', dest='verbose', action='count', default=0,
                   help='verbose output. specify twice for debug-level output.')
    p.add_argument('-o', '--outdir', dest='outdir', action='store', type=str,
                   default='autobackup',
                   help='Output directory; default: autobackup/')
    p.add_argument('BACKUP', action='store', type=str, help='Backup file')
    args = p.parse_args(argv)
    return args


def set_log_info():
    """set logger level to INFO"""
    set_log_level_format(logging.INFO,
                         '%(asctime)s %(levelname)s:%(name)s:%(message)s')


def set_log_debug():
    """set logger level to DEBUG, and debug-level output format"""
    set_log_level_format(
        logging.DEBUG,
        "%(asctime)s [%(levelname)s %(filename)s:%(lineno)s - "
        "%(name)s.%(funcName)s() ] %(message)s"
    )


def set_log_level_format(level, format):
    """
    Set logger level and format.

    :param level: logging level; see the :py:mod:`logging` constants.
    :type level: int
    :param format: logging formatter format string
    :type format: str
    """
    formatter = logging.Formatter(fmt=format)
    logger.handlers[0].setFormatter(formatter)
    logger.setLevel(level)


if __name__ == "__main__":
    args = parse_args(sys.argv[1:])

    # set logging level
    if args.verbose > 1:
        set_log_debug()
    elif args.verbose == 1:
        set_log_info()

    UnifiBackupDecrypter().run(args.BACKUP, outdir=args.outdir)
